<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>目标是成为算法小师,第二集</title>
    <link href="/2025/09/16/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0_%E5%9B%BE%E6%90%9C/"/>
    <url>/2025/09/16/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0_%E5%9B%BE%E6%90%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="图搜索"><a href="#图搜索" class="headerlink" title="图搜索"></a>图搜索</h1><h4 id="定义：省流"><a href="#定义：省流" class="headerlink" title="定义：省流"></a>定义：省流</h4><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="思路模板"><a href="#思路模板" class="headerlink" title="思路模板:"></a>思路模板:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">result = []<br>def backtrack(路径, 选择列表):<br>    <span class="hljs-keyword">if</span> 满足结束条件:<br>        result.add(路径)<br>        <span class="hljs-built_in">return</span><br>    <br>    <span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>        做选择<br>        backtrack(路径, 选择列表)<br>        撤销选择<br></code></pre></td></tr></table></figure><h3 id="典型的迷宫问题"><a href="#典型的迷宫问题" class="headerlink" title="典型的迷宫问题"></a>典型的迷宫问题</h3><p>$$<br>现有一个<br>n∗m 大小的迷宫，其中1表示不可通过的墙壁，0表示平地。每次移动只能向上下左右移动一格（不允许移动到曾经经过的位置），且只能移动到平地上。现从迷宫左上角出发，问能否在恰好第<br>k<br>k 步时到达右下角。</p><p>输入描述<br>第一行三个整数 </p><p>n、</p><p>m、</p><p>k<br>(<br>2<br>≤<br>n<br>≤<br>5<br>,<br>2<br>≤<br>m<br>≤<br>5<br>,<br>2<br>≤<br>k<br>≤<br>n<br>×<br>m<br>)<br>(2≤n≤5,2≤m≤5,2≤k≤n×m),分别表示迷宫的行数、列数、移动的步数；</p><p>接下来<br>n<br>n 行，每行<br>m<br>m 个整数（值为0或1），表示迷宫。</p><p>输出描述<br>如果可行，那么输出Yes，否则输出No。<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">典型的迷宫问题:<br><span class="hljs-comment">#现有一个 n∗m大小的迷宫，其中1表示不可通过的墙壁，0表示平地。</span><br><span class="hljs-comment">#每次移动只能向上下左右移动一格（不允许移动到曾经经过的位置）</span><br><span class="hljs-comment">#且只能移动到平地上。现从迷宫左上角出发，问能否在恰好第 k 步时到达右下角</span><br>n,m,k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>mat = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    mat.append(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())))<br>step,xnow,ynow=<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">xnow,ynow,step,xlast=<span class="hljs-number">0</span>,ylast=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-keyword">if</span> xnow==n-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> ynow==m-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> step==k:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">elif</span> step&gt;k:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<span class="hljs-comment">#现在往四个方向走</span><br>        <span class="hljs-keyword">for</span> dx,dy <span class="hljs-keyword">in</span> [(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>),(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),(-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)]:<br>            <span class="hljs-keyword">if</span> xnow+dx&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ynow+dy&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> xnow+dx&lt;n <span class="hljs-keyword">and</span> ynow+dy&lt;m <span class="hljs-keyword">and</span> mat[xnow+dx][ynow+dy]==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> (xnow+dx!=xlast <span class="hljs-keyword">or</span> ynow+dy!=ylast):<br>                <span class="hljs-keyword">if</span> backtrack(xnow+dx,ynow+dy,step+<span class="hljs-number">1</span>,xnow,ynow):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span> <span class="hljs-keyword">if</span> backtrack(xnow,ynow,step) <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;No&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">思路模板:<br><span class="hljs-comment"># 从 s 开始 BFS 遍历图的所有节点，且记录遍历的步数</span><br>def bfs(graph, s, target):<br>    visited = [False] * len(graph)<br>    q = deque([s])<br>    visited[s] = True<br>    <span class="hljs-comment"># 记录从 s 开始走到当前节点的步数</span><br>    step = 0<br>    <br>    <span class="hljs-keyword">while</span> q:<br>        sz = len(q)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(sz):<br>            cur = q.popleft()<br>            <span class="hljs-built_in">print</span>(f<span class="hljs-string">&quot;visit &#123;cur&#125; at step &#123;step&#125;&quot;</span>)<br>            <span class="hljs-comment"># 判断是否到达终点</span><br>            <span class="hljs-keyword">if</span> cur == target:<br>                <span class="hljs-built_in">return</span> step<br><br>            <span class="hljs-comment"># 将邻居节点加入队列，向四周扩散搜索</span><br>            <span class="hljs-keyword">for</span> to <span class="hljs-keyword">in</span> neighborsOf(cur):<br>                <span class="hljs-keyword">if</span> not visited[to]:<br>                    q.append(to)<br>                    visited[to] = True<br>        step += 1<br>    <span class="hljs-comment"># 如果走到这里，说明在图中没有找到目标节点</span><br>    <span class="hljs-built_in">return</span> -1<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>目标是成为算法小师,第一集</title>
    <link href="/2025/09/16/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0_%E6%B8%90%E8%BF%9B%E5%88%86%E6%9E%90/"/>
    <url>/2025/09/16/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0_%E6%B8%90%E8%BF%9B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="渐进分析"><a href="#渐进分析" class="headerlink" title="渐进分析"></a>渐进分析</h1><h2 id="大O分析法"><a href="#大O分析法" class="headerlink" title="大O分析法"></a>大O分析法</h2><p>实际上一言以蔽之<br>$$<br>只要存在n_{0}，当n&gt;n_{0}时，对于任意g（n）都有常数c，使得\f（n）&lt;&#x3D; c g(n) \<br>那么就可以用O表示 f（n）&#x3D; O（g（n）） 并不一定是最极限的那一个<br>$$<br><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1758027220463.png" alt="1758027220463"></p><p>例如此题，A和B都应该是对的，所以选C。</p><h2 id="大Omega分析法"><a href="#大Omega分析法" class="headerlink" title="大Omega分析法"></a>大Omega分析法</h2><p>一言以蔽之<br>$$<br>只要存在n_{0}，当n&gt;n_{0}时，对于任意g（n）都有常数c，使得\f（n）&gt;&#x3D; c g(n) \<br>那么就可以用O表示 f（n）&#x3D; Ω（g（n）） 并不一定是最极限的那一个<br>$$<br><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1758028456414.png" alt="1758028456414"></p><p>此处理解<br>$$<br>排序的本质是从n!选取一个情况，每次一一比较，最多要比较log_{2}n!次 \又有log(n!)&#x3D;Ω(nlogn) 即选上<br>$$</p><h2 id="大Theta表示法"><a href="#大Theta表示法" class="headerlink" title="大Theta表示法"></a>大Theta表示法</h2><p>即我们常用的时间复杂度表示方法 要求同前 对于任意n&gt;n0,存在c1,c2使得 c1 g(n) &lt; f(n) &lt; c2g(n)即可</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1758028929090.png" alt="1758028929090"></p><p>常见数学问题不多赘述<br><strong>线性Linear时间：O（n）</strong></p><p>eg：合并升序数组</p><p>实际上就是将两个数组分别遍历一遍逐个比较,利用了原数组排好序的特殊性</p><p><strong>对数Logarithmic时间：O（logn）</strong></p><p>eg：二分查找，循环数组查找，排序算法</p><p>循环数组主要是利用了至少有一个局部有序的半区进行二分查找</p><p><strong>多项式Ploynomial时间:O(n^k)</strong></p><p>k-独立集问题 输入一张图，找出𝑘 个点， 使任意两个点之间没有边。 </p><p>  枚举所有𝑘个点的子集  判断是否为独立集  </p><p><strong>指数Exponential时间 :O(2^(n^k))</strong></p><p>最大独立集问题 输入一张图，找出满足任意 两个点之间没有边的最大的顶点子集。 </p><p> 枚举所有顶点的子集  判断是否为独立集  </p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一切的起点</title>
    <link href="/2025/09/16/%E9%80%86%E5%90%91day01/"/>
    <url>/2025/09/16/%E9%80%86%E5%90%91day01/</url>
    
    <content type="html"><![CDATA[<p> <a href="https://adworld.xctf.org.cn/challenges/list">攻防世界</a>  XCTF-逆向-666</p><p>在看完第一题的题解之后，开始尝试独立攻破第二题，耗时一个半小时，拼尽全力配合AI大人战胜，逆向，很奇妙吧，以下是我的思路分享。</p><p>看题解里面的大佬开局还要判断文件格式和壳判断，但是我不会后面再学，开局直接找到main函数，美滋滋。</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1758015471553.png" alt="1758015471553"></p><p>分析，right的条件是 strcmp(s,enflag)&#x3D;&#x3D;0 即s和enflag相同 s需要处理，去找找enflag</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1758015552888.png" alt="1758015552888"></p><p>双击enflag就找到了 美滋滋 然后还要保证v5的长度为key，大佬们都是直接找到key&#x3D;12h&#x3D;18，我还多绕了几步</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1758015628880.png" alt="1758015628880"></p><p>分析a2即返回的s，s长度要和enflag相同，那s就长18，那么函数里面就是18，反向推出key&#x3D;18，接下来就是编写python脚本反向解密这个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">enflag = <span class="hljs-string">&#x27;izwhroz&quot;&quot;w&quot;v.K&quot;.Ni&#x27;</span>;<br>key = <span class="hljs-number">18</span>;<br>flag=<span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">18</span>,<span class="hljs-number">3</span>):<br>    flag+=<span class="hljs-built_in">chr</span>((<span class="hljs-built_in">ord</span>(enflag[i])^<span class="hljs-number">18</span>)-<span class="hljs-number">6</span>)<br>    flag+=<span class="hljs-built_in">chr</span>((<span class="hljs-built_in">ord</span>(enflag[i+<span class="hljs-number">1</span>])^<span class="hljs-number">18</span>)+<span class="hljs-number">6</span>)<br>    flag+=<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(enflag[i+<span class="hljs-number">2</span>])^<span class="hljs-number">18</span>^<span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><p>注意的是异或符号优先级没有减号高 需要小括号 一开始没注意，搞了半天还出错了，最后得到flag&#x3D;unctf{b66_6b6_66b}；</p><p>题解收获：</p>]]></content>
    
    
    
    <tags>
      
      <tag>网安</tag>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/09/16/hello-world/"/>
    <url>/2025/09/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
